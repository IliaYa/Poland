СДАВАТЬ КОД ИЗ ТЕКСТОГОГО ФАЙЛА ИЛИ ИЗ СКОБКИ А?
A, B, C ПРОВЕРЕНЫ НА ИНФОРМАТИКСЕ. СДАВАЙ ИХ!!!
Задача Z.
Для хранения архива данных на устройствах резервного копирования вам поручили написать класс,
который не просто умеет архивировать и разархивировать файл, но и разбивает полученный архив на несколько частей
в зависимости от размера имеющихся устройств хранения. Размер каждой части(кроме помледней) фиксирован,
а имена полученных файлов должны получаться получаться из имени исходного файла добавлением в конец чисел
1, 2...,N соответсвенно(например, 'hello.zip1', 'hello.zip2', 'hello.zip3').

Новый класс HugeArchieve, наследуемый от класса из стандартной библиотеки python, предназначенного для работы с
архивами в формате ZIP, должен реализовывать все те же методы со следующими отличиями:

В методе init в качестве дополнительного последнего параметра part_size(по умолчанию равного 10)
передается количество байт в каждой части(кроме последней части, в которой может оказаться больше,
чем part_size байт).
Например, если на вход конструктора передается "a.zip", он создаёт его конкатенацией содежимого файлов
"a.zip1", "a.zip2", ... (всех имеющихся в указанном месте файлы с последовательными номерами).

Вносить исправление в другие методы не нужно.

Примеры кода, который должен корректно работать при наличии корректных файлов metanit.zip1, metanit.zip2,...:

with HugeArchieve("metanit.zip", "r") as myzip:
    foritem inmyzip.infolist():
        if (item.is_dir()):
            print(f"Папка: {item.filename}")
        else:
            print(f"Файл: {item.filename}")

with HugeArchieve("metanit.zip", "a") as myzip:
    #записываем в архив новый файл "hello5.txt"
    with myzip.open("hello5.txt", "w") as hello_file:
        encoded_str = bytes("Python...", "UTF-8")
        hello_file.write(encoded_str)
